// crypto-ts: cryptography primitives and wrappers
// Copyright 2026 Dark Bio AG. All rights reserved.
//
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

//! HKDF cryptography wrappers and parametrization.
//!
//! https://datatracker.ietf.org/doc/html/rfc5869

use wasm_bindgen::prelude::*;

/// Derives a key from the secret, salt, and info using HKDF-SHA256, returning a
/// byte array that can be used as a cryptographic key.
///
/// Panics if out_len exceeds the maximum output length for SHA-256 HKDF, which is
/// 255 * 32 = 8160 bytes.
#[wasm_bindgen]
pub fn hkdf_key(secret: &[u8], salt: &[u8], info: &[u8], out_len: usize) -> Vec<u8> {
    darkbio_crypto::hkdf::key_with_len(secret, salt, info, out_len)
}

/// Generates a pseudorandom key for use with hkdf_expand from an input secret
/// and an optional independent salt.
///
/// Only use this function if you need to reuse the extracted key with multiple
/// expand invocations and different context values. Most common scenarios,
/// including the generation of multiple keys, should use hkdf_key instead.
#[wasm_bindgen]
pub fn hkdf_extract(secret: &[u8], salt: &[u8]) -> Vec<u8> {
    darkbio_crypto::hkdf::extract(secret, salt).to_vec()
}

/// Derives a key using the given pseudorandom key and optional context info,
/// skipping the extraction step.
///
/// The pseudorandom key should have been generated by hkdf_extract, or be a
/// uniformly random or pseudorandom cryptographically strong key. See RFC 5869,
/// Section 3.3. Most common scenarios will want to use hkdf_key instead.
#[wasm_bindgen]
pub fn hkdf_expand(prk: &[u8], info: &[u8], out_len: usize) -> Result<Vec<u8>, JsError> {
    let prk: [u8; 32] = prk
        .try_into()
        .map_err(|_| JsError::new("prk must be 32 bytes"))?;
    Ok(darkbio_crypto::hkdf::expand_with_len(prk, info, out_len))
}
